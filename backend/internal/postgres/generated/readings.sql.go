// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: readings.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDeviceReadings = `-- name: CountDeviceReadings :one
SELECT COUNT(*) AS count
FROM sensor_readings
WHERE device_id = $1
`

func (q *Queries) CountDeviceReadings(ctx context.Context, deviceID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countDeviceReadings, deviceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDeviceReadings = `-- name: GetDeviceReadings :many
SELECT id, device_id, payload, timestamp
FROM sensor_readings
WHERE device_id = $1
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type GetDeviceReadingsParams struct {
	DeviceID int64 `json:"device_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

func (q *Queries) GetDeviceReadings(ctx context.Context, arg GetDeviceReadingsParams) ([]SensorReading, error) {
	rows, err := q.db.Query(ctx, getDeviceReadings, arg.DeviceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SensorReading{}
	for rows.Next() {
		var i SensorReading
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Payload,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeviceReadingsPaged = `-- name: GetDeviceReadingsPaged :many
SELECT id, device_id, payload, timestamp
FROM sensor_readings
WHERE device_id = $1
  AND timestamp < $2
ORDER BY timestamp DESC
LIMIT $3 OFFSET $4
`

type GetDeviceReadingsPagedParams struct {
	DeviceID  int64     `json:"device_id"`
	Timestamp time.Time `json:"timestamp"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetDeviceReadingsPaged(ctx context.Context, arg GetDeviceReadingsPagedParams) ([]SensorReading, error) {
	rows, err := q.db.Query(ctx, getDeviceReadingsPaged,
		arg.DeviceID,
		arg.Timestamp,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SensorReading{}
	for rows.Next() {
		var i SensorReading
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Payload,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadingByID = `-- name: GetReadingByID :one
SELECT id, device_id, payload, timestamp
FROM sensor_readings
WHERE id = $1
`

func (q *Queries) GetReadingByID(ctx context.Context, id int64) (SensorReading, error) {
	row := q.db.QueryRow(ctx, getReadingByID, id)
	var i SensorReading
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Payload,
		&i.Timestamp,
	)
	return i, err
}

const getReadingsByDate = `-- name: GetReadingsByDate :many
SELECT id, device_id, payload, timestamp
FROM sensor_readings
WHERE device_id = $1
  AND timestamp >= $2::date
  AND timestamp <  ($2::date + INTERVAL '1 day')
ORDER BY timestamp DESC
`

type GetReadingsByDateParams struct {
	DeviceID int64       `json:"device_id"`
	Column2  pgtype.Date `json:"column_2"`
}

func (q *Queries) GetReadingsByDate(ctx context.Context, arg GetReadingsByDateParams) ([]SensorReading, error) {
	rows, err := q.db.Query(ctx, getReadingsByDate, arg.DeviceID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SensorReading{}
	for rows.Next() {
		var i SensorReading
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Payload,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadingsByTimeRange = `-- name: GetReadingsByTimeRange :many
SELECT id, device_id, payload, timestamp
FROM sensor_readings
WHERE device_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
ORDER BY timestamp ASC
`

type GetReadingsByTimeRangeParams struct {
	DeviceID    int64     `json:"device_id"`
	Timestamp   time.Time `json:"timestamp"`
	Timestamp_2 time.Time `json:"timestamp_2"`
}

func (q *Queries) GetReadingsByTimeRange(ctx context.Context, arg GetReadingsByTimeRangeParams) ([]SensorReading, error) {
	rows, err := q.db.Query(ctx, getReadingsByTimeRange, arg.DeviceID, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SensorReading{}
	for rows.Next() {
		var i SensorReading
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Payload,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertReading = `-- name: InsertReading :one
INSERT INTO sensor_readings (device_id, payload)
VALUES ($1, $2)
RETURNING id, device_id, payload, timestamp
`

type InsertReadingParams struct {
	DeviceID int64  `json:"device_id"`
	Payload  []byte `json:"payload"`
}

func (q *Queries) InsertReading(ctx context.Context, arg InsertReadingParams) (SensorReading, error) {
	row := q.db.QueryRow(ctx, insertReading, arg.DeviceID, arg.Payload)
	var i SensorReading
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Payload,
		&i.Timestamp,
	)
	return i, err
}
