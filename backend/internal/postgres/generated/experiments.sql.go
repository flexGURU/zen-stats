// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: experiments.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countListExperiments = `-- name: CountListExperiments :one
SELECT COUNT(*) AS total_experiments
FROM experiments
WHERE deleted_at IS NULL
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(batch_id) LIKE $1
        OR LOWER(operator) LIKE $1
        OR LOWER(block_id) LIKE $1
    )
    AND (
        $2::bigint IS NULL 
        OR reactor_id = $2
    )
    AND (
        $3::timestamptz IS NULL 
        OR date = $3
    )
`

type CountListExperimentsParams struct {
	Search    interface{}        `json:"search"`
	ReactorID pgtype.Int8        `json:"reactor_id"`
	Date      pgtype.Timestamptz `json:"date"`
}

func (q *Queries) CountListExperiments(ctx context.Context, arg CountListExperimentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countListExperiments, arg.Search, arg.ReactorID, arg.Date)
	var total_experiments int64
	err := row.Scan(&total_experiments)
	return total_experiments, err
}

const createExperiment = `-- name: CreateExperiment :one
INSERT INTO experiments (
    batch_id, operator, date, reactor_id, block_id, time_start, time_end,
    material_feedstock, exposure_conditions, analtical_tests
)
VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9, $10
)
RETURNING id, batch_id, operator, date, reactor_id, block_id, time_start, time_end, material_feedstock, exposure_conditions, analtical_tests, deleted_at, created_at
`

type CreateExperimentParams struct {
	BatchID            string      `json:"batch_id"`
	Operator           string      `json:"operator"`
	Date               time.Time   `json:"date"`
	ReactorID          int64       `json:"reactor_id"`
	BlockID            string      `json:"block_id"`
	TimeStart          pgtype.Time `json:"time_start"`
	TimeEnd            pgtype.Time `json:"time_end"`
	MaterialFeedstock  []byte      `json:"material_feedstock"`
	ExposureConditions []byte      `json:"exposure_conditions"`
	AnalticalTests     []byte      `json:"analtical_tests"`
}

func (q *Queries) CreateExperiment(ctx context.Context, arg CreateExperimentParams) (Experiment, error) {
	row := q.db.QueryRow(ctx, createExperiment,
		arg.BatchID,
		arg.Operator,
		arg.Date,
		arg.ReactorID,
		arg.BlockID,
		arg.TimeStart,
		arg.TimeEnd,
		arg.MaterialFeedstock,
		arg.ExposureConditions,
		arg.AnalticalTests,
	)
	var i Experiment
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.Operator,
		&i.Date,
		&i.ReactorID,
		&i.BlockID,
		&i.TimeStart,
		&i.TimeEnd,
		&i.MaterialFeedstock,
		&i.ExposureConditions,
		&i.AnalticalTests,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExperiment = `-- name: DeleteExperiment :exec
UPDATE experiments
SET deleted_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteExperiment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteExperiment, id)
	return err
}

const getExperimentByID = `-- name: GetExperimentByID :one
SELECT id, batch_id, operator, date, reactor_id, block_id, time_start, time_end, material_feedstock, exposure_conditions, analtical_tests, deleted_at, created_at FROM experiments WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetExperimentByID(ctx context.Context, id int64) (Experiment, error) {
	row := q.db.QueryRow(ctx, getExperimentByID, id)
	var i Experiment
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.Operator,
		&i.Date,
		&i.ReactorID,
		&i.BlockID,
		&i.TimeStart,
		&i.TimeEnd,
		&i.MaterialFeedstock,
		&i.ExposureConditions,
		&i.AnalticalTests,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listExperiments = `-- name: ListExperiments :many
SELECT id, batch_id, operator, date, reactor_id, block_id, time_start, time_end, material_feedstock, exposure_conditions, analtical_tests, deleted_at, created_at FROM experiments
WHERE deleted_at IS NULL
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(batch_id) LIKE $1
        OR LOWER(operator) LIKE $1
        OR LOWER(block_id) LIKE $1
    )
    AND (
        $2::bigint IS NULL 
        OR reactor_id = $2
    )
    AND (
        $3::timestamptz IS NULL 
        OR date = $3
    )
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type ListExperimentsParams struct {
	Search    interface{}        `json:"search"`
	ReactorID pgtype.Int8        `json:"reactor_id"`
	Date      pgtype.Timestamptz `json:"date"`
	Offset    int32              `json:"offset"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) ListExperiments(ctx context.Context, arg ListExperimentsParams) ([]Experiment, error) {
	rows, err := q.db.Query(ctx, listExperiments,
		arg.Search,
		arg.ReactorID,
		arg.Date,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Experiment{}
	for rows.Next() {
		var i Experiment
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.Operator,
			&i.Date,
			&i.ReactorID,
			&i.BlockID,
			&i.TimeStart,
			&i.TimeEnd,
			&i.MaterialFeedstock,
			&i.ExposureConditions,
			&i.AnalticalTests,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExperiment = `-- name: UpdateExperiment :one
UPDATE experiments
SET
    batch_id = $1,
    operator = $2,
    date = $3,
    reactor_id = $4,
    block_id = $5,
    time_start = $6,
    time_end = $7,
    material_feedstock = $8,
    exposure_conditions = $9,
    analtical_tests = $10
WHERE id = $11 AND deleted_at IS NULL
RETURNING id, batch_id, operator, date, reactor_id, block_id, time_start, time_end, material_feedstock, exposure_conditions, analtical_tests, deleted_at, created_at
`

type UpdateExperimentParams struct {
	BatchID            string      `json:"batch_id"`
	Operator           string      `json:"operator"`
	Date               time.Time   `json:"date"`
	ReactorID          int64       `json:"reactor_id"`
	BlockID            string      `json:"block_id"`
	TimeStart          pgtype.Time `json:"time_start"`
	TimeEnd            pgtype.Time `json:"time_end"`
	MaterialFeedstock  []byte      `json:"material_feedstock"`
	ExposureConditions []byte      `json:"exposure_conditions"`
	AnalticalTests     []byte      `json:"analtical_tests"`
	ID                 int64       `json:"id"`
}

func (q *Queries) UpdateExperiment(ctx context.Context, arg UpdateExperimentParams) (Experiment, error) {
	row := q.db.QueryRow(ctx, updateExperiment,
		arg.BatchID,
		arg.Operator,
		arg.Date,
		arg.ReactorID,
		arg.BlockID,
		arg.TimeStart,
		arg.TimeEnd,
		arg.MaterialFeedstock,
		arg.ExposureConditions,
		arg.AnalticalTests,
		arg.ID,
	)
	var i Experiment
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.Operator,
		&i.Date,
		&i.ReactorID,
		&i.BlockID,
		&i.TimeStart,
		&i.TimeEnd,
		&i.MaterialFeedstock,
		&i.ExposureConditions,
		&i.AnalticalTests,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}
